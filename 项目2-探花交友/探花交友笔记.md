# 一、JWT

## 简介

**JSON Web token**简称JWT， 是用于对应用程序上的用户进行**身份验证**的标记。也就是说, 使用 JWTS 的应用程序不再需要保存有关其用户的 cookie 或其他session数据。此特性便于可伸缩性, 同时保证应用程序的安全。

可以通过JWT来判断用户是否登录，用户是否有相应的权限等。

## 格式

* JWT就是一个**字符串**，经过加密处理与校验处理的字符串，形式为：**A.B.C**

* A由JWT头部信息**header**经过base64编码得到

* B由身份验证信息**json数据**经过base64编码得到

* C由A和B加密得到，是校验部分

![image-20210714121154190](img/image-20210714121154190.png)

由于 B 部分是通过base64编码得到，所以**不能用于存放敏感信息**



## 鉴权原理

![image-20210714121203246](img/image-20210714121203246.png)





## JWT代码用法

导入依赖：

~~~xml
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt</artifactId>
    <version>0.9.1</version>
</dependency>
~~~

编写测试用例：

~~~java
    @Test
    public void testCreateToken() {
        //生成token
        //1、准备数据
        Map map = new HashMap();
        map.put("id",1);
        map.put("mobile","13800138000");
        //2、使用JWT的工具类生成token
        long now = System.currentTimeMillis();
        String token = Jwts.builder()
                .signWith(SignatureAlgorithm.HS512, "itcast") //指定加密算法，以及签名的密钥
                .setClaims(map) //写入数据
                .setExpiration(new Date(now + 30000)) //失效时间
                .compact();
        System.out.println(token);
    }

    //解析token

    /**
     * SignatureException : token不合法
     * ExpiredJwtException：token已过期
     */
    @Test
    public void testParseToken() {
        String token = "eyJhbGciOiJIUzUxMiJ9.eyJtb2JpbGUiOiIxMzgwMDEzODAwMCIsImlkIjoxLCJleHAiOjE2MTgzOTcxOTV9.2lQiovogL5tJa0px4NC-DW7zwHFqZuwhnL0HPAZunieGphqnMPduMZ5TtH_mxDrgfiskyAP63d8wzfwAj-MIVw";
        try {
            Claims claims = Jwts.parser()
                    .setSigningKey("itcast")	//指定该token签名的密钥，必须和生成token时指定的一致
                    .parseClaimsJws(token)
                    .getBody();
           
            Object id = claims.get("id");
            Object mobile = claims.get("mobile");
            System.out.println(id + "--" + mobile);
        }catch (ExpiredJwtException e) {
            System.out.println("token已过期");
        }catch (SignatureException e) {
            System.out.println("token不合法");
        }

    }
~~~

通过解析Token得知，如果抛出**SignatureException**异常表示**token不合法**，如果抛出**ExpiredJwtException**异常表示**token已过期**



# 二、用户登录

用户接收到验证码后，进行输入验证码，点击登录，前端系统将手机号以及验证码提交到服务端进行校验。

![image-20210714121439345](img/image-20210714121439345.png)

~~~java
    /**
     * 验证登录
     * @param phone
     * @param code
     */
    public Map loginVerification(String phone, String code) {
        //1、从redis中获取下发的验证码
        String redisCode = redisTemplate.opsForValue().get("CHECK_CODE_" + phone);
        //2、对验证码进行校验（验证码是否存在，是否和输入的验证码一致）
        if(StringUtils.isEmpty(redisCode) || !redisCode.equals(code)) {
            //验证码无效
             throw new RuntimeException();
        }
        //3、删除redis中的验证码
        redisTemplate.delete("CHECK_CODE_" + phone);
        //4、通过手机号码查询用户
        User user = userApi.findByMobile(phone);
        boolean isNew = false;
        //5、如果用户不存在，创建用户保存到数据库中
        if(user == null) {
            user = new User();
            user.setMobile(phone);
            user.setPassword(DigestUtils.md5Hex("123456"));
            Long userId = userApi.save(user);
            user.setId(userId);
            isNew = true;
        }
        //6、通过JWT生成token(存入id和手机号码)
        Map tokenMap = new HashMap();
        tokenMap.put("id",user.getId());
        tokenMap.put("mobile",phone);
        String token = JwtUtils.getToken(tokenMap);
        //7、构造返回值
        Map retMap = new HashMap();
        retMap.put("token",token);
        retMap.put("isNew",isNew);

        return retMap;
    }
~~~



# 三、VO DTO Entity对比

**VO（Value Object）**值对象，通常用于服务端与界面之间的数据传递。对于一个WEB页面，用一个VO对象对应整个界面的值。

**DTO（Data Transfer Object）**数据传输对象，通常用于界面向服务端的数据传递

**Entity** 最常用实体类，基本和数据表一一对应，一个实体一张表（常说的实体类，Domain）

![image-20220602190803175](img/image-20220602190803175.png)



# 四、FastDFS

FastDFS是分布式文件系统。使用 FastDFS很容易搭建一套高性能的文件服务器集群提供文件上传、下载等服务。

## 工作原理

FastDFS 架构包括 **Tracker server** 和 **Storage server**。

客户端请求 Tracker server 进行文件上传、下载，通过 Tracker server 调度最终由 Storage server 完成文件上传和下载。

**Tracker server** 作用是负载均衡和调度，通过 Tracker server 在文件上传时可以根据一些策略找到 Storage server 提供文件上传服务。可以将 tracker 称为追踪服务器或调度服务器。

**Storage server** 作用是文件存储，客户端上传的文件最终存储在 Storage 服务器上，Storage server 没有实现自己的文件系统而是利用操作系统的文件系统来管理文件。可以将storage称为存储服务器。

 ![6bd41a6af1fef5cc89dda7c94208c6a64f3.png](img/6bd41a6af1fef5cc89dda7c94208c6a64f3.png)

每个 tracker 节点地位平等。收集 Storage 集群的状态。

Storage 分为多个组，每个组之间保存的文件是不同的。每个组内部可以有多个成员，组成员内部保存的内容是一样的，组成员的地位是一致的，没有主从的概念。



文件存储到Storage server服务器上。为了方便http访问调用，每个Storage server还要绑定一个nginx：



![image-20220613144611591](img/image-20220613144611591.png)

### 文件上传

![image-20220613144942371](img/image-20220613144942371.png)



客户端上传文件后存储服务器将文件 ID 返回给客户端，此文件 ID 用于以后访问该文件的索引信息。

文件索引信息包括：组名，虚拟磁盘路径，数据两级目录，文件名。

### 文件下载

![image-20220613145105015](img/image-20220613145105015.png)

客户端下载请求到Tracker服务，Tracker返回给客户端storage的信息，客户端根据这些信息进行请求storage获取到文件。

## 通过Java Client实现文件上传

* 导入依赖（已经存在，被注释）

* 在application.yml中配置Fastdfs

* 注入**FastFileStorageClient**对象，完成文件上传

  

#### 导入依赖

找到`tanhua-app-server`的pom文件，添加 fastdfs 的依赖如下

```xml
<dependency>
    <groupId>com.github.tobato</groupId>
    <artifactId>fastdfs-client</artifactId>
    <version>1.26.7</version>
    <exclusions>
        <exclusion>
            <groupId>ch.qos.logback</groupId>
            <artifactId>logback-classic</artifactId>
        </exclusion>
    </exclusions>
</dependency>
```

#### application.yml

```properties
fdfs:
  so-timeout: 1500
  connect-timeout: 600
  #缩略图生成参数
  thumb-image:
    width: 150
    height: 150
  #TrackerList参数,支持多个
  tracker-list: 192.168.136.160:22122
  web-server-url: http://192.168.136.160:8888/
```

#### 文件上传代码

```java
@RunWith(SpringRunner.class)
@SpringBootTest(classes = TanhuaServerApplication.class)
public class TestFastDFS {

    //测试将文件上传到FastDFS文件系统中

    //从调度服务器获取，一个目标存储服务器，上传
    @Autowired
    private FastFileStorageClient client;

    @Autowired
    private FdfsWebServer webServer;// 获取存储服务器的请求URL

    @Test
    public void testFileUpdate() throws FileNotFoundException {
         //1、指定文件
        File file = new File("D:\\1.jpg");
        //2、文件上传，参数：文件输入流、文件长度、文件扩展名、文件元数据信息（一般为空）
        //通过返回值可以获取文件存储的路径
        StorePath path = client.uploadFile(new FileInputStream(file),
                file.length(), "jpg", null);
        //3、拼接访问路径
        String url = webServer.getWebServerUrl() + path.getFullPath();
    }
}
```

